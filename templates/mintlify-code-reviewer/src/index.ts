import * as dotenv from "dotenv";
import { createAgent, createOpenAILLM } from "spinai";
import { serve } from "@hono/node-server";
import { Hono } from "hono";
import { analyzeCodeChanges } from "./actions/analyzeCodeChanges";
import { analyzeDocStructure } from "./actions/analyzeDocStructure";
import { planDocUpdates } from "./actions/planDocUpdates";
import { generateContent } from "./actions/generateContent";
import { updateNavigation } from "./actions/updateNavigation";
import { createDocsPR } from "./actions/createDocsPR";
import { ReviewState, DocUpdateConfig } from "./types";
dotenv.config();

const defaultConfig: DocUpdateConfig = {
  docsDir: "docs",
  matchRules: {
    docExtensions: [".mdx", ".md"],
    ignorePatterns: ["**/node_modules/**", "**/.git/**"],
  },
  prConfig: {
    updateOriginalPr: false,
    branchPrefix: "docs/update",
    titleTemplate: "ðŸ“š Update documentation for {prTitle}",
    bodyTemplate: `This PR updates documentation to reflect changes in #{prNumber}

## Changes
{changes}

This PR was automatically generated by the documentation maintainer.`,
    labels: ["documentation"],
  },
};

interface CreateDocUpdateAgentOptions {
  config?: Partial<DocUpdateConfig>;
  openAiKey?: string;
  githubToken?: string;
  port?: number;
}

export function createDocUpdateAgent(
  options: CreateDocUpdateAgentOptions = {}
) {
  const config: DocUpdateConfig = {
    ...defaultConfig,
    ...options.config,
    matchRules: {
      ...defaultConfig.matchRules,
      ...options.config?.matchRules,
    },
    prConfig: {
      ...defaultConfig.prConfig,
      ...options.config?.prConfig,
      updateOriginalPr:
        options.config?.prConfig?.updateOriginalPr ??
        defaultConfig.prConfig.updateOriginalPr,
    },
  };

  const openAiKey = options.openAiKey || process.env.OPENAI_API_KEY;
  const githubToken = options.githubToken || process.env.GITHUB_TOKEN;

  if (!openAiKey) throw new Error("OpenAI API key is required");
  if (!githubToken) throw new Error("GitHub token is required");

  const llm = createOpenAILLM({
    apiKey: openAiKey,
    model: "gpt-4-turbo-preview",
  });

  const agent = createAgent<ReviewState>({
    instructions: `You are a documentation maintenance agent that helps keep documentation in sync with code changes.
    When code changes are made in a pull request, you:
    1. Analyze the code changes to understand what functionality has changed
    2. Analyze the existing documentation structure and relationships
    3. Plan necessary documentation updates based on the changes
    4. Generate precise, accurate documentation updates
    5. Update navigation structure in mint.json as needed
    6. ${config.prConfig.updateOriginalPr ? "Update the original PR" : "Create a new PR"} with the documentation updates
    
    Your documentation updates should:
    - Be clear and concise
    - Match the existing documentation style
    - Include code examples where relevant
    - Update any API references, parameters, or return types
    - Maintain the existing formatting
    ${config.llmConfig?.styleGuide ? `\nStyle Guide:\n${config.llmConfig.styleGuide}` : ""}`,
    actions: [
      analyzeCodeChanges,
      analyzeDocStructure,
      planDocUpdates,
      generateContent,
      updateNavigation,
      createDocsPR,
    ],
    llm,
  });

  const app = new Hono();

  app.post("/webhook", async (c) => {
    try {
      const event = c.req.header("x-github-event");
      if (!event) return c.json({ error: "No GitHub event header found" }, 400);

      // Parse the payload, handling both JSON and form-encoded
      let body;
      const contentType = c.req.header("content-type") || "";

      if (contentType.includes("application/json")) {
        body = await c.req.json();
      } else if (contentType.includes("application/x-www-form-urlencoded")) {
        const formData = await c.req.parseBody();
        if (typeof formData.payload === "string") {
          body = JSON.parse(formData.payload);
        } else {
          throw new Error("Invalid payload format");
        }
      } else {
        return c.json({ error: "Unsupported content type" }, 400);
      }

      // Validate the payload structure
      if (
        !body?.pull_request?.number ||
        !body?.repository?.owner?.login ||
        !body?.repository?.name ||
        !body?.action
      ) {
        return c.json({ error: "Invalid webhook payload structure" }, 400);
      }

      // Skip processing if this is a PR created by our bot
      if (
        body.pull_request.title.startsWith("ðŸ“š Update documentation") ||
        (body.pull_request.labels || []).some(
          (label: any) => label.name === "documentation"
        )
      ) {
        console.log("Skipping bot-created documentation PR");
        return c.json({ message: "Skipping bot PR" });
      }

      if (
        event !== "pull_request" ||
        !["opened", "synchronize"].includes(body.action)
      ) {
        return c.json({ message: "Event ignored" });
      }

      const { pull_request, repository } = body;

      try {
        console.log(
          `Processing PR #${pull_request.number} from ${repository.owner.login}/${repository.name}`
        );

        const result = await agent({
          input: `Review pull request #${pull_request.number}`,
          externalCustomerId: repository.owner.login,
          state: {
            owner: repository.owner.login,
            repo: repository.name,
            pull_number: pull_request.number,
            config,
          },
        });

        // Log the result for debugging/mocking
        console.log("\n=== Processing Result ===");
        // console.log(JSON.stringify(result, null, 2));
        console.log("======================\n");

        return c.json({
          message: "Documentation update completed",
          ...result,
        });
      } catch (error) {
        console.error("Error:", error);
        return c.json(
          {
            error: "Failed to process documentation update",
            details: error instanceof Error ? error.message : String(error),
          },
          500
        );
      }
    } catch (error) {
      console.error("Webhook error:", error);
      return c.json(
        {
          error: "Webhook processing failed",
          details: error instanceof Error ? error.message : String(error),
        },
        500
      );
    }
  });

  const port = options.port || parseInt(process.env.PORT || "3000", 10);
  console.log(`Starting server on port ${port}...`);

  serve({
    fetch: app.fetch,
    port,
  });

  console.log(`ðŸš€ Server is running at http://localhost:${port}`);

  return agent;
}
